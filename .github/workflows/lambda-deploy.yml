name: Deploy TravelStyle to Lambda

on:
  push:
    branches: [main]
    paths: ['backend/**', '.github/workflows/**']
  workflow_dispatch:
  workflow_run:
    workflows: ["Backend Quality CI/CD"]
    types: [completed]
    branches: [main]

# Optional: Add manual approval for production deployments
# Uncomment the following to require manual approval:
# environment:
#   name: production
#   url: ${{ steps.deploy.outputs.url }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    concurrency:
      group: lambda-deployment
      cancel-in-progress: true

    env:
      FUNCTION_NAME: ${{ secrets.LAMBDA_FUNCTION_NAME }}
      REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
      API_NAME: TravelStyleAPI

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for ongoing deployments
        run: |
          # Check if there are any ongoing Lambda updates
          if aws lambda get-function --function-name $FUNCTION_NAME &>/dev/null; then
            STATE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text 2>/dev/null || echo "Unknown")
            LAST_MODIFIED=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.LastModified' --output text 2>/dev/null || echo "")

            echo "Current function state: $STATE"
            echo "Last modified: $LAST_MODIFIED"

            if [ "$STATE" != "Active" ]; then
              echo "‚ö†Ô∏è  Function is not in Active state ($STATE). Waiting for any ongoing updates..."
              # Wait up to 5 minutes for function to become active
              for i in {1..10}; do
                sleep 30
                STATE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text 2>/dev/null || echo "Unknown")
                echo "Attempt $i: Function state is $STATE"
                if [ "$STATE" = "Active" ]; then
                  echo "‚úÖ Function is now Active, proceeding with deployment"
                  break
                fi
                if [ $i -eq 10 ]; then
                  echo "‚ùå Function did not become Active after 5 minutes"
                  exit 1
                fi
              done
            fi
          fi

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create Lambda package
        run: |
          cd backend

          # Create build directory
          mkdir -p build

          # Install dependencies (exclude unnecessary files)
          pip install -r requirements.txt --target build --no-cache-dir --no-deps

          # Copy only necessary application code
          cp -r app build/

          # Remove unnecessary files to reduce package size
          cd build
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "*.pyc" -delete 2>/dev/null || true
          find . -type d -name "tests" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true

          # Create deployment package
          zip -r ../lambda-deploy.zip . -x "*.pyc" "__pycache__/*" "tests/*" "*.egg-info/*"
          cd ..

          echo "Package size: $(du -h lambda-deploy.zip | cut -f1)"

      - name: Deploy to Lambda
        run: |
          cd backend

          # Mask secrets
          echo "::add-mask::$OPENAI_API_KEY"
          echo "::add-mask::$OPENAI_ORG_ID"
          echo "::add-mask::$QLOO_API_KEY"
          echo "::add-mask::$OPENWEATHER_API_KEY"
          echo "::add-mask::$EXCHANGE_API_KEY"
          echo "::add-mask::$SUPABASE_URL"
          echo "::add-mask::$SUPABASE_KEY"
          echo "‚úÖ Secrets validated and masked"

          # Check if function exists and wait for any ongoing updates
          if aws lambda get-function --function-name $FUNCTION_NAME &>/dev/null; then
            echo "Function exists, checking for ongoing updates..."

            # Wait for any ongoing updates to complete
            for i in {1..10}; do
              STATE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text 2>/dev/null || echo "Unknown")
              if [ "$STATE" = "Active" ]; then
                echo "Function is in Active state, proceeding with update"
                break
              else
                echo "Function state: $STATE, waiting 30 seconds (attempt $i/10)..."
                sleep 30
                if [ $i -eq 10 ]; then
                  echo "Function did not become active after 10 attempts, proceeding anyway"
                fi
              fi
            done
          fi

          # Create environment variables
          cat > env.json << EOF
          {
            "Variables": {
              "OPENAI_API_KEY": "${{ secrets.OPENAI_API_KEY }}",
              "OPENAI_ORG_ID": "${{ secrets.OPENAI_ORG_ID }}",
              "QLOO_API_KEY": "${{ secrets.QLOO_API_KEY }}",
              "OPENWEATHER_API_KEY": "${{ secrets.OPENWEATHER_API_KEY }}",
              "EXCHANGE_API_KEY": "${{ secrets.EXCHANGE_API_KEY }}",
              "SUPABASE_URL": "${{ secrets.SUPABASE_URL }}",
              "SUPABASE_KEY": "${{ secrets.SUPABASE_KEY }}",
              "API_V1_STR": "/api/v1",
              "PROJECT_NAME": "TravelStyle AI",
              "VERSION": "1.0.0"
            }
          }
          EOF

          # Deploy or update function with retry logic
          if aws lambda get-function --function-name $FUNCTION_NAME &>/dev/null; then
            echo "Updating existing function..."

            # Update function code first
            aws lambda update-function-code --function-name $FUNCTION_NAME --zip-file fileb://lambda-deploy.zip

            # Wait for code update to complete
            echo "Waiting for code update to complete..."
            aws lambda wait function-updated --function-name $FUNCTION_NAME

            # Update configuration with retry logic
            echo "Updating function configuration..."
            for i in {1..5}; do
              if aws lambda update-function-configuration \
                --function-name $FUNCTION_NAME \
                --environment file://env.json \
                --timeout 30 \
                --memory-size 512; then
                echo "Configuration updated successfully"
                break
              else
                echo "Attempt $i: Configuration update failed, waiting 30 seconds..."
                sleep 30
                if [ $i -eq 5 ]; then
                  echo "Failed to update configuration after 5 attempts"
                  exit 1
                fi
              fi
            done
          else
            echo "Creating new function..."
            aws lambda create-function \
              --function-name $FUNCTION_NAME \
              --runtime python3.13 \
              --handler app.main.handler \
              --role arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):role/TravelStyle-Lambda-Role \
              --zip-file fileb://lambda-deploy.zip \
              --environment file://env.json \
              --timeout 30 \
              --memory-size 512
          fi

      - name: Setup API Gateway
        run: |
          # Get or create API Gateway
          API_ID=$(aws apigatewayv2 get-apis --query "Items[?Name=='$API_NAME'].ApiId" --output text 2>/dev/null || echo "")

          if [ -z "$API_ID" ] || [ "$API_ID" = "None" ]; then
            API_ID=$(aws apigatewayv2 create-api --name "$API_NAME" --protocol-type HTTP --query "ApiId" --output text)
          fi

          # Create integration
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          LAMBDA_ARN="arn:aws:lambda:$REGION:$ACCOUNT_ID:function:$FUNCTION_NAME"

          INTEGRATION_ID=$(aws apigatewayv2 create-integration \
            --api-id $API_ID \
            --integration-type AWS_PROXY \
            --integration-uri $LAMBDA_ARN \
            --payload-format-version 2.0 \
            --query 'IntegrationId' --output text 2>/dev/null || echo "")

          # Create routes
          aws apigatewayv2 create-route --api-id $API_ID --route-key "ANY /" --target "integrations/$INTEGRATION_ID" 2>/dev/null || echo "Route exists"
          aws apigatewayv2 create-route --api-id $API_ID --route-key "ANY /{proxy+}" --target "integrations/$INTEGRATION_ID" 2>/dev/null || echo "Route exists"

          # Create stage
          aws apigatewayv2 create-stage --api-id $API_ID --stage-name '$default' --auto-deploy 2>/dev/null || echo "Stage exists"

          # Set permissions
          aws lambda add-permission \
            --function-name $FUNCTION_NAME \
            --statement-id "api-gateway-invoke" \
            --action lambda:InvokeFunction \
            --principal apigateway.amazonaws.com \
            --source-arn "arn:aws:execute-api:$REGION:$ACCOUNT_ID:$API_ID/*/*/*" 2>/dev/null || echo "Permission exists"

          # Output endpoint
          ENDPOINT="https://$API_ID.execute-api.$REGION.amazonaws.com"
          echo "API_ENDPOINT=$ENDPOINT" >> $GITHUB_ENV
          echo "‚úÖ Deployed to: $ENDPOINT"

      - name: Emergency cancel check
        if: failure()
        run: |
          echo "üö® Deployment failed - checking for stuck Lambda updates..."

          # Check if Lambda function is stuck in updating state
          if aws lambda get-function --function-name $FUNCTION_NAME &>/dev/null; then
            STATE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text 2>/dev/null || echo "Unknown")
            echo "Current Lambda function state: $STATE"

            if [ "$STATE" = "Pending" ] || [ "$STATE" = "InProgress" ]; then
              echo "‚ö†Ô∏è  Lambda function is still updating. This may take a few minutes to complete."
              echo "You can check the status with: aws lambda get-function --function-name $FUNCTION_NAME"
            fi
          fi

      - name: Test deployment
        run: |
          sleep 10

          # Test health endpoint and validate response
          HEALTH_RESPONSE=$(curl -s $API_ENDPOINT/health)

          if [ $? -eq 0 ]; then
            echo "‚úÖ Health endpoint responded successfully"
            echo "Response: $HEALTH_RESPONSE"

            # Check if response contains expected JSON
            if echo "$HEALTH_RESPONSE" | grep -q '"status": "healthy"' && echo "$HEALTH_RESPONSE" | grep -q '"cache": "supabase"'; then
              echo "‚úÖ Health check validation passed - expected JSON structure found"
            else
              echo "‚ùå Health check validation failed - unexpected response format"
              echo "Expected: {\"status\": \"healthy\", \"cache\": \"supabase\"}"
              echo "Received: $HEALTH_RESPONSE"
              exit 1
            fi
          else
            echo "‚ùå Health check failed - endpoint not responding"
            exit 1
          fi

          echo "üéâ TravelStyle API deployed successfully!"
          echo "üåê Endpoint: $API_ENDPOINT"
